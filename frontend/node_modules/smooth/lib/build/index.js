"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildBrowser = buildBrowser;
exports.buildSchemaDefinition = buildSchemaDefinition;
exports.buildSchema = buildSchema;
exports.watchSchema = watchSchema;
exports.buildWebpack = buildWebpack;
exports.watchWebpack = watchWebpack;

var _path = _interopRequireDefault(require("path"));

var _webpack = _interopRequireDefault(require("webpack"));

var _nodeHooks = require("../plugin/nodeHooks");

var _graphql = require("../graphql");

var _cache = require("./cache");

var _watcher = require("./watcher");

var _webpackMiddleware = _interopRequireDefault(require("./webpackMiddleware"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function getPluginFileContent(config) {
  const definitions = config.plugins.filter(plugin => plugin.browser).map((plugin, index) => {
    const file = _path.default.join(plugin.resolve, 'smooth-browser');

    return `{ plugin: require('${file}'), options: ${JSON.stringify(plugin.options)} }`;
  });
  return `module.exports = [${definitions.join(',\n')}]`;
}

async function buildBrowser({
  config
}) {
  const cache = (0, _cache.createCache)({
    config
  }); // Create empty default-blocks directory

  await cache.createDirectory('default-blocks'); // Write browser plugins

  await cache.writeCacheFile('browser-plugins.js', getPluginFileContent(config));
}

async function buildSchemaDefinition({
  config
}) {
  const schemaDefinition = await (0, _graphql.createSchemaDefinition)({
    config
  });
  const schema = (0, _graphql.makeExecutableSchema)(schemaDefinition);
  return {
    schemaDefinition,
    schema
  };
}

async function buildSchema({
  config
}) {
  const cache = (0, _cache.createCache)({
    config
  });
  const {
    schemaDefinition,
    schema
  } = await buildSchemaDefinition({
    config
  });
  await (0, _nodeHooks.onBuild)(config)({
    schemaDefinition
  });
  const fragmentTypes = await (0, _graphql.getFragmentTypes)({
    schema
  });
  await cache.writeCacheFile('fragmentTypes.json', JSON.stringify(fragmentTypes));
  return {
    schema,
    fragmentTypes
  };
}

function watchSchema(_ref) {
  let {
    logger
  } = _ref,
      options = _objectWithoutPropertiesLoose(_ref, ["logger"]);

  const watcher = new _watcher.Watcher(async () => logger(buildSchema(options)));
  (0, _watcher.watchFs)(options.config.srcPath, () => watcher.tick());
  return watcher;
}

async function buildWebpack({
  config
}) {
  const compiler = (0, _webpack.default)(config.webpackConfig);
  return new Promise((resolve, reject) => {
    compiler.run((err, stats) => {
      if (err) {
        reject(err);
      } else {
        resolve(stats);
      }
    });
  });
}

function watchWebpack({
  config,
  logger
}) {
  const resolver = {
    done: result => {
      if (resolver.resolve) {
        resolver.resolve(result);
        resolver.resolve = null;
      }
    },
    task: async () => {
      if (resolver.resolve) return;
      resolver.promise = new Promise(resolve => {
        resolver.resolve = resolve;
      });
      return logger(resolver.promise);
    }
  };
  const watcher = new _watcher.Watcher(resolver.task);
  watcher.tick();
  const middleware = (0, _webpackMiddleware.default)({
    config
  }, compiler => {
    compiler.hooks.done.tap('smooth', (compiler, stats) => {
      resolver.done(stats);
    });
    compiler.hooks.invalid.tap('smooth', (filename, changeTime) => {
      if (!filename.match(/\/\.smooth\//)) {
        watcher.tick();
      }
    });
  });
  watcher.middleware = middleware;
  return watcher;
}