"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefinitionModules = getDefinitionModules;
exports.createSchemaDefinitionMock = createSchemaDefinitionMock;
exports.createSchemaDefinition = createSchemaDefinition;
exports.createSchema = createSchema;
Object.defineProperty(exports, "makeExecutableSchema", {
  enumerable: true,
  get: function () {
    return _graphqlTools.makeExecutableSchema;
  }
});
exports.mergeResolvers = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _mergeDeep = _interopRequireDefault(require("merge-deep"));

var _util = require("util");

var _path = _interopRequireDefault(require("path"));

var _tinyGlob = _interopRequireDefault(require("tiny-glob"));

var _graphqlTools = require("graphql-tools");

var _language = require("graphql/language");

var _definitions = require("../definitions");

var _blockType = require("./blockType");

var _contentType = require("./contentType");

var _node = require("../../plugin/node");

var _require = _interopRequireDefault(require("../../babel/require"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const exists = (0, _util.promisify)(_fs.default.exists);

function sanitizeDefinition(options) {
  return {
    typeDefs: options.typeDefs || null,
    resolvers: options.resolvers || {}
  };
}

const mergeResolvers = _mergeDeep.default;
exports.mergeResolvers = mergeResolvers;

function mergeSchemaDefinitions(definitions) {
  return {
    typeDefs: (0, _language.parse)((0, _graphqlTools.concatenateTypeDefs)(definitions.map(def => def.typeDefs).filter(Boolean))),
    resolvers: mergeResolvers(...definitions.map(def => def.resolvers))
  };
}

async function getDefinitionModules({
  config
}) {
  const schemasExists = await exists(config.schemasPath);
  if (!schemasExists) return [];
  const files = await (0, _tinyGlob.default)('**/*.js', {
    cwd: config.schemasPath
  });
  const defs = files.map(relativePath => {
    const absolutePath = _path.default.join(config.schemasPath, relativePath);

    if (!config.cache) {
      delete require.cache[absolutePath];
    } // eslint-disable-next-line global-require, import/no-dynamic-require


    return (0, _require.default)(absolutePath);
  });
  return defs;
}

function createSchemaDefinitionMock(...definitions) {
  const schemaDefinition = mergeSchemaDefinitions([..._definitions.definitions, ...definitions].map(sanitizeDefinition));
  (0, _blockType.addBlockTypeDefinitions)(schemaDefinition);
  (0, _contentType.addContentTypeDefinitions)(schemaDefinition);
  return schemaDefinition;
}

async function createSchemaDefinition({
  config
}) {
  const projectDefinitions = await getDefinitionModules({
    config
  });
  const schemaDefinition = mergeSchemaDefinitions([..._definitions.definitions, ...projectDefinitions].map(sanitizeDefinition));
  (0, _blockType.addBlockTypeDefinitions)(schemaDefinition);
  (0, _contentType.addContentTypeDefinitions)(schemaDefinition);
  await (0, _node.applyAsyncHook)(config, 'onCreateSchemaDefinition', {
    schemaDefinition
  });
  return schemaDefinition;
}

async function createSchema({
  schemaDefinition
}) {
  return (0, _graphqlTools.makeExecutableSchema)(schemaDefinition);
}